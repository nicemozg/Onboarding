package main

import (
	"fmt"
	"sync"
)

func main() {
	// Инициализируем слайс с числами
	numbers := []int{1, 2, 3, 4, 5}

	// Генерируем канал с числами из слайса
	in := gen(numbers...)

	// Создаем два канала для возведения чисел в квадрат
	c1 := sq(in)
	c2 := sq(in)

	// Читаем и выводим значения из объединенного канала
	for n := range merge(c1, c2) {
		fmt.Println(n)
	}
}

// Функция gen принимает переменное количество целых чисел и возвращает канал
func gen(nums ...int) <-chan int {
	out := make(chan int)
	go func() {
		for _, n := range nums { // Итерируем по каждому числу в переданном списке
			out <- n // Отправляем число в канал
		}
		close(out) // Закрываем канал после отправки всех чисел
	}()
	return out
}

// Функция sq принимает канал с числами, возводит их в квадрат и возвращает новый канал
func sq(in <-chan int) <-chan int {
	out := make(chan int)
	go func() {
		for n := range in { // Итерируем по каждому числу, полученному из входного канала
			out <- n * n // Отправляем квадрат числа в выходной канал
		}
		close(out) // Закрываем канал после обработки всех чисел
	}()
	return out
}

// Функция merge принимает несколько каналов и возвращает один объединенный канал
func merge(cs ...<-chan int) <-chan int {
	var wg sync.WaitGroup // Используем WaitGroup для ожидания завершения всех горутин
	out := make(chan int)

	// Анонимная функция для передачи значений из входного канала в выходной
	output := func(c <-chan int) {
		for n := range c {
			out <- n // Отправляем значение из входного канала в выходной
		}
		wg.Done() // Сообщаем WaitGroup о завершении работы горутины
	}

	wg.Add(len(cs))        // Устанавливаем количество ожидаемых горутин
	for _, c := range cs { // Запускаем горутину для каждого входного канала
		go output(c)
	}

	// Анонимная функция для закрытия выходного канала после завершения всех горутин
	go func() {
		wg.Wait()  // Ждем завершения всех горутин
		close(out) // Закрываем выходной канал
	}()
	return out
}
