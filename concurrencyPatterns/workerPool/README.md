# Пример паттерна Worker Pool в Go

Данный код демонстрирует использование паттерна `Worker Pool` в языке Go. Этот паттерн используется для управления и ограничения количества горутин, работающих одновременно.

## Описание кода

### Функция worker

Функция `worker` принимает три параметра:
- `id` (int): Идентификатор рабочего.
- `jobs` (<-chan int): Канал для получения задач.
- `results` (chan<- int): Канал для отправки результатов.
- `wg` (*sync.WaitGroup): Группа ожидания для синхронизации горутин.

Функция читает задачи из канала `jobs`, выполняет их (в данном случае, умножает значение на 2) и отправляет результат в канал `results`. После завершения работы, горутина вызывает `wg.Done()` для уменьшения счётчика горутин в группе ожидания.

```go
func worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {
    defer wg.Done()
    for j := range jobs {
        fmt.Printf("worker %d started job %d\n", id, j)
        results <- j * 2
    }
}
```

### Функция main

В функции `main` выполняются следующие шаги:

1. Определяется количество задач `numJobs`.
2. Создаются каналы `jobs` и `results` с буфером размером `numJobs`.
3. Создается переменная `wg` типа `sync.WaitGroup` для синхронизации горутин.
4. Запускаются 3 горутины рабочих с использованием функции `worker`. Каждой горутине передается идентификатор, канал задач, канал результатов и указатель на группу ожидания.
5. В канал `jobs` отправляются задачи, после чего канал закрывается.
6. Ожидание завершения всех горутин с помощью `wg.Wait()`.
7. Закрытие канала `results`.
8. Чтение и вывод результатов из канала `results`.

```go
func main() {
    const numJobs = 5
    jobs := make(chan int, numJobs)
    results := make(chan int, numJobs)
    var wg sync.WaitGroup

    for w := 1; w <= 3; w++ {
        wg.Add(1)
        go worker(w, jobs, results, &wg)
    }

    for j := 1; j <= numJobs; j++ {
        jobs <- j
    }
    close(jobs)

    wg.Wait()
    close(results)

    for result := range results {
        fmt.Println("Result:", result)
    }
}
```

### Вывод

При запуске данного кода, мы увидим, как три рабочих 
горутины параллельно обрабатывают пять задач. Результаты выполнения задач выводятся на экран.

```worker 1 started job 1
worker 3 started job 1
worker 3 started job 3
worker 3 started job 4
worker 3 started job 5
worker 1 started job 2
Result: 2
Result: 6
Result: 8
Result: 10
Result: 4
```

Таким образом, данный пример демонстрирует, как можно эффективно использовать паттерн `Worker Pool` для выполнения параллельных задач в `Go`.

### Итоги

* Основная горутина отправляет задачи в канал jobs.
* Рабочие горутины параллельно читают задачи из канала jobs, обрабатывают их и отправляют результаты в канал results.
* Основная горутина ждёт завершения всех рабочих горутин и затем читает результаты из канала results.

Этот подход обеспечивает асинхронное и параллельное выполнение задач, что улучшает производительность программы и позволяет эффективно использовать ресурсы.

