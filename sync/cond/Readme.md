### Объяснение примера

#### Использование sync.Cond и sync.Mutex в Go

В данном примере демонстрируется использование условной переменной (`sync.Cond`) вместе с мьютексом (`sync.Mutex`) для организации ожидания сигнала от одной горутины другой.

#### Основные компоненты

1. **Инициализация мьютекса и условной переменной:**
   - Создается мьютекс `mu` с помощью `sync.Mutex`, который будет использоваться для защиты доступа к общему состоянию.
   - Создается условная переменная `cond` с помощью `sync.NewCond(&mu)`, которая будет использоваться для ожидания и уведомления горутин.

2. **Горутина, ожидающая сигнала:**
   - Запускается анонимная функция в новой горутине (`go func()`), которая блокирует мьютекс (`mu.Lock()`).
   - В цикле проверяется переменная `ready`, пока она не станет `true`.
   - Для ожидания изменения состояния используется `cond.Wait()`, который автоматически освобождает мьютекс и блокирует текущую горутину до получения сигнала от другой горутины.
   - После получения сигнала выводится сообщение `"Goroutine notified"`, и мьютекс разблокируется (`mu.Unlock()`).

3. **Основная горутина:**
   - Блокирует мьютекс `mu.Lock()` перед изменением общего состояния.
   - Устанавливает переменную `ready` в `true`, что означает, что готово к выполнению действий, которые должны быть синхронизированы.
   - Вызывает `cond.Signal()`, чтобы отправить сигнал одной из ожидающих горутин, что общее состояние изменилось.
   - Разблокирует мьютекс `mu.Unlock()`.

#### Как это работает

- При запуске программы создается две горутины: одна ожидает сигнала изменения состояния, а другая изменяет состояние и отправляет сигнал.
- Использование мьютекса `mu` и условной переменной `cond` позволяет безопасно ожидать изменения состояния и уведомлять о нем другие горутины.
- `sync.Cond` автоматически управляет мьютексом внутри себя, что делает использование условных переменных удобным и безопасным для конкурентной среды Go.

#### Заключение

Этот пример демонстрирует применение условных переменных и мьютексов в Go для синхронизации работы между горутинами. Эти механизмы являются важными инструментами для разработки безопасных и эффективных многопоточных приложений на языке Go.
