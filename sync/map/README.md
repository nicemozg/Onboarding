1. Импортируемые пакеты

```go
import (
    "fmt"
    "sync"
)
```

Здесь мы импортируем два пакета: fmt для форматированного вывода и sync для использования примитивов синхронизации, в данном случае sync.Map.

2. Создание переменной типа sync.Map

```go
var m sync.Map
```

Объявляем переменную m типа sync.Map. Это специальная структура данных, которая предоставляет безопасный для конкурентного использования словарь (map).

3. Метод Store

```go
m.Store("key", "value")
```

Метод Store сохраняет значение в sync.Map. Он принимает два параметра: ключ и значение. В данном случае, ключом является строка "key", а значением - строка "value". Этот метод безопасен для использования из разных горутин одновременно.

4. Метод Load

```go
value, ok := m.Load("key")
if ok {
    fmt.Println("Loaded value:", value)
}
```

Метод Load загружает значение, связанное с указанным ключом. Он возвращает два значения: само значение и булевый флаг, указывающий, было ли найдено значение для данного ключа.

+  Если значение найдено, то ok будет true, и мы выведем его на экран с помощью fmt.Println.
+  Если значение не найдено, ok будет false.

В данном случае, мы ожидаем, что значение будет найдено, так как мы только что сохранили его с помощью Store.

5. Метод Range

```go
m.Range(func(key, value interface{}) bool {
    fmt.Println(key, value)
    return true
})
```

Метод Range позволяет итерировать по всем ключам и значениям, сохраненным в sync.Map. Он принимает функцию в качестве аргумента, которая вызывается для каждой пары ключ-значение в карте.

+  Функция, переданная в Range, принимает два параметра: ключ и значение, оба типа interface{}, так как sync.Map поддерживает произвольные типы данных для ключей и значений.
+  Внутри функции мы просто выводим ключ и значение на экран.

Функция должна возвращать bool. Если функция возвращает true, итерация продолжается. Если возвращает false, итерация прекращается. В данном случае, мы всегда возвращаем true, чтобы итерировать по всем элементам карты.

### Вывод программы

Запустив эту программу, мы увидим следующий вывод:

```go
Loaded value: value
key value
```

+  Первая строка (Loaded value: value) появляется после успешного вызова метода Load.
+  Вторая строка (key value) появляется в результате итерации по карте с помощью метода Range

Таким образом, мы убедились, что значение было успешно сохранено и загружено, а также корректно итерировано.

### Важные моменты

+  Блокировка карты: Во время выполнения метода Range карту блокируют, чтобы обеспечить безопасность конкурентного доступа из нескольких горутин. Это позволяет безопасно итерироваться по элементам карты без риска гонок данных.
+  Условный выход: Вы можете использовать условие в функции обратного вызова для раннего прекращения итерации (return false), если это необходимо. Например, если вы достигли нужного вам элемента или выполнен какой-то условный критерий.

Использование метода Range делает работу с sync.Map удобной и безопасной для многопоточной обработки данных, обеспечивая эффективную итерацию по всем элементам карты.

### Рекомендации по использованию Range

+  Только чтение: Используйте метод Range только для чтения данных из карты и выполнения операций, которые не изменяют состояние карты.

+  Избегайте побочных эффектов: Не выполняйте операции, которые могут изменять состояние или структуру карты, такие как удаление элементов (Delete) или изменение значений (Store).

+  Атомарные операции: Если вам нужно изменить состояние карты, сначала закончите итерацию с помощью Range, а затем выполните необходимые операции с картой в отдельной части кода, чтобы избежать гонок данных.

### sync.Map в Go 
предоставляет следующие методы для работы с параллельной картой:

1. Store(key, value interface{})

* Добавляет указанное значение value по ключу key.
* Если ключ key уже существует, значение value будет заменено.

2. Load(key interface{}) (value interface{}, ok bool)

* Возвращает значение, связанное с указанным ключом key.
* Если ключ key найден, возвращает значение и ok = true.
* Если ключ key отсутствует, возвращает nil и ok = false.

3. LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)

+ Пытается найти значение по ключу key.
+ Если ключ key найден, возвращает текущее значение и loaded = true.
+ Если ключ key отсутствует, добавляет указанное значение value по ключу key и возвращает его, а loaded = false.

4. Delete(key interface{})
+ Удаляет значение, связанное с указанным ключом key.

5. Range(f func(key, value interface{}) bool)

+ Итерирует по всем элементам карты и вызывает функцию f для каждой пары ключ-значение.
+ Функция f должна возвращать true, чтобы продолжить итерацию, или false, чтобы прекратить её.

Пример использования методов sync.Map

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var m sync.Map

    // Добавление элементов в карту
    m.Store("key1", "value1")
    m.Store("key2", "value2")
    m.Store("key3", "value3")

    // Загрузка значения по ключу
    value, ok := m.Load("key2")
    if ok {
        fmt.Println("Loaded value:", value)
    }

    // Загрузка или добавление значения
    actualValue, loaded := m.LoadOrStore("key4", "value4")
    if loaded {
        fmt.Println("Existing value loaded:", actualValue)
    } else {
        fmt.Println("New value stored:", actualValue)
    }

    // Удаление элемента
    m.Delete("key1")

    // Итерация по карты с использованием Range
    m.Range(func(key, value interface{}) bool {
        fmt.Println("Key:", key, "Value:", value)
        return true // Продолжаем итерацию
    })
}
```