### Инициализация и использование контекста с дедлайном

1. Установка дедлайна:

```go
deadline := time.Now().Add(5 * time.Second)
```

Здесь устанавливается дедлайн, который наступит через 5 секунд от текущего времени.

2. Создание контекста с дедлайном:

```go
ctx, cancel := context.WithDeadline(context.Background(), deadline)
```

Функция context.WithDeadline создает новый контекст ctx с дедлайном, установленным на значение deadline. В этой строке также создается функция cancel, которая должна быть вызвана для освобождения ресурсов, связанных с контекстом, когда они больше не нужны.

3. Отложенный вызов cancel:

```go
defer cancel()
```

Здесь используется defer для того, чтобы гарантировать вызов cancel() при завершении функции main(). Это важно, чтобы освободить ресурсы, связанные с контекстом.

4. Ожидание завершения контекста:

```go
select {
case <-ctx.Done():
    fmt.Println("Context is done due to deadline")
}
```

Конструкция select ждет завершения контекста. В данном случае канал <-ctx.Done() закроется, когда контекст будет завершен, что произойдет либо по достижении дедлайна, либо при явном вызове cancel(). Когда контекст завершится, выполняется вывод сообщения "`Context is done due to deadline`".

Как это работает

+ Сначала устанавливается дедлайн на `5 секунд` в будущем.
+ Затем создается новый контекст `ctx` с этим дедлайном, и функция `cancel` для этого контекста.
+ С помощью `defer cancel()` гарантируется, что `cancel()` будет вызван перед завершением функции `main()`, что позволяет освободить любые ресурсы, связанные с этим контекстом.
+ Конструкция `select` ждет завершения контекста. Когда дедлайн наступит (через 5 секунд), контекст будет завершен, и канал `<-ctx.Done()` получит сигнал, что приведет к выполнению блока `case` и выводу сообщения на экран.

Таким образом, этот пример показывает, как использовать контекст с дедлайном для выполнения операций с тайм-аутом и гарантировать освобождение ресурсов после завершения работы с контекстом.